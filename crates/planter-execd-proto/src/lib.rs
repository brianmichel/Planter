use std::collections::BTreeMap;

use planter_core::{CommandSpec, ErrorCode, ExitStatus, JobId, SessionId, TerminationReason};
use serde::{Deserialize, Serialize};

/// Protocol version used by `planterd` <-> `planter-execd` control RPC.
pub const EXECD_PROTOCOL_VERSION: u32 = 1;

/// Worker request envelope with request id metadata.
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct ExecRequestEnvelope {
    /// Caller-assigned request identifier.
    pub req_id: u64,
    /// Typed request body.
    pub body: ExecRequest,
}

/// Worker response envelope with request id metadata.
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct ExecResponseEnvelope {
    /// Request identifier echoed from request envelope.
    pub req_id: u64,
    /// Typed response body.
    pub body: ExecResponse,
}

/// PTY operations acknowledged by the worker.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum ExecPtyAction {
    /// Session was opened.
    Opened,
    /// Input bytes were accepted.
    Input,
    /// Terminal size was updated.
    Resize,
    /// Session was closed.
    Closed,
}

/// Worker-specific error codes used in `ExecResponse::ExecError`.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum ExecErrorCode {
    /// Request shape or semantics were invalid.
    InvalidRequest,
    /// Referenced resource does not exist.
    NotFound,
    /// Authentication or authorization failed.
    Unauthorized,
    /// Worker is temporarily unavailable.
    Unavailable,
    /// Requested operation is not supported.
    Unsupported,
    /// Unexpected internal failure.
    Internal,
}

/// Requests accepted by a `planter-execd` worker.
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum ExecRequest {
    /// Performs protocol/auth handshake.
    Hello {
        /// Expected protocol version.
        protocol: u32,
        /// Shared secret generated by daemon.
        auth_token: String,
        /// Logical cell identifier attached to the worker.
        cell_id: String,
    },
    /// Lightweight liveness probe.
    Ping {},
    /// Starts a new job process.
    RunJob {
        /// Job identifier assigned by daemon.
        job_id: JobId,
        /// Command specification.
        cmd: CommandSpec,
        /// Effective environment overrides.
        env: BTreeMap<String, String>,
        /// Destination path for stdout log stream.
        stdout_path: String,
        /// Destination path for stderr log stream.
        stderr_path: String,
    },
    /// Reads current state for a job.
    JobStatus {
        /// Target job identifier.
        job_id: JobId,
    },
    /// Requests job termination.
    JobSignal {
        /// Target job identifier.
        job_id: JobId,
        /// When true, apply a forceful kill.
        force: bool,
    },
    /// Opens an interactive PTY session.
    PtyOpen {
        /// Shell binary path.
        shell: String,
        /// Shell argument vector.
        args: Vec<String>,
        /// Optional initial working directory.
        cwd: Option<String>,
        /// Environment overrides.
        env: BTreeMap<String, String>,
        /// Initial columns.
        cols: u16,
        /// Initial rows.
        rows: u16,
    },
    /// Writes input bytes to a PTY session.
    PtyInput {
        /// Target session identifier.
        session_id: SessionId,
        /// Raw input bytes.
        data: Vec<u8>,
    },
    /// Reads PTY output bytes from an offset.
    PtyRead {
        /// Target session identifier.
        session_id: SessionId,
        /// Read offset in bytes.
        offset: u64,
        /// Maximum bytes to return.
        max_bytes: u32,
        /// Whether to follow for more output.
        follow: bool,
        /// Follow timeout in milliseconds.
        wait_ms: u64,
    },
    /// Resizes a PTY session.
    PtyResize {
        /// Target session identifier.
        session_id: SessionId,
        /// Terminal columns.
        cols: u16,
        /// Terminal rows.
        rows: u16,
    },
    /// Closes a PTY session.
    PtyClose {
        /// Target session identifier.
        session_id: SessionId,
        /// When true, force-close resources.
        force: bool,
    },
    /// Samples process usage for a job.
    UsageProbe {
        /// Target job identifier.
        job_id: JobId,
    },
    /// Shuts the worker down.
    Shutdown {
        /// When true, stop immediately.
        force: bool,
    },
}

/// Responses returned by a `planter-execd` worker.
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum ExecResponse {
    /// Successful hello handshake result.
    HelloAck {
        /// Worker protocol version.
        protocol: u32,
        /// Worker process id.
        worker_pid: u32,
    },
    /// Ping response.
    Pong {},
    /// Job start acknowledgment.
    JobStarted {
        /// Job identifier.
        job_id: JobId,
        /// Child pid if available.
        pid: Option<u32>,
    },
    /// Current job status.
    JobStatus {
        /// Job identifier.
        job_id: JobId,
        /// Running or exited status.
        status: ExitStatus,
        /// Optional finish timestamp.
        finished_at_ms: Option<u64>,
        /// Optional termination cause.
        termination_reason: Option<TerminationReason>,
    },
    /// PTY open acknowledgment.
    PtyOpened {
        /// Session identifier.
        session_id: SessionId,
        /// Shell pid if available.
        pid: Option<u32>,
    },
    /// PTY output chunk.
    PtyChunk {
        /// Session identifier.
        session_id: SessionId,
        /// Offset after this chunk.
        offset: u64,
        /// Raw output bytes.
        data: Vec<u8>,
        /// True when no further bytes are immediately available.
        eof: bool,
        /// True when underlying shell has exited.
        complete: bool,
        /// Exit code when complete.
        exit_code: Option<i32>,
    },
    /// PTY control acknowledgment.
    PtyAck {
        /// Session identifier.
        session_id: SessionId,
        /// Operation acknowledged by worker.
        action: ExecPtyAction,
    },
    /// Usage sample payload.
    UsageSample {
        /// Job identifier.
        job_id: JobId,
        /// Resident set size in bytes.
        rss_bytes: Option<u64>,
        /// CPU usage in nanoseconds.
        cpu_nanos: Option<u64>,
        /// Sample timestamp in UNIX milliseconds.
        timestamp_ms: u64,
    },
    /// Structured worker error.
    ExecError {
        /// High-level worker error category.
        code: ExecErrorCode,
        /// Human-readable summary.
        message: String,
        /// Optional diagnostic context.
        detail: Option<String>,
    },
}

impl From<ErrorCode> for ExecErrorCode {
    /// Maps shared daemon error categories into worker-local error categories.
    fn from(value: ErrorCode) -> Self {
        match value {
            ErrorCode::InvalidRequest => ExecErrorCode::InvalidRequest,
            ErrorCode::NotFound => ExecErrorCode::NotFound,
            ErrorCode::Timeout => ExecErrorCode::Unavailable,
            ErrorCode::ProtocolMismatch => ExecErrorCode::InvalidRequest,
            ErrorCode::Unavailable => ExecErrorCode::Unavailable,
            ErrorCode::Internal => ExecErrorCode::Internal,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::{
        EXECD_PROTOCOL_VERSION, ExecRequest, ExecRequestEnvelope, ExecResponse,
        ExecResponseEnvelope,
    };
    use planter_core::CommandSpec;
    use std::collections::BTreeMap;

    #[test]
    /// Verifies hello request envelope CBOR roundtrips correctly.
    fn roundtrip_hello_request() {
        let request = ExecRequestEnvelope {
            req_id: 42,
            body: ExecRequest::Hello {
                protocol: EXECD_PROTOCOL_VERSION,
                auth_token: "abc123".to_string(),
                cell_id: "cell-1".to_string(),
            },
        };
        let bytes = serde_cbor::to_vec(&request).expect("encode request");
        let decoded =
            serde_cbor::from_slice::<ExecRequestEnvelope>(&bytes).expect("decode request");
        assert_eq!(decoded, request);
    }

    #[test]
    /// Verifies run-job request envelope CBOR roundtrips correctly.
    fn roundtrip_run_job_request() {
        let request = ExecRequestEnvelope {
            req_id: 7,
            body: ExecRequest::RunJob {
                job_id: planter_core::JobId("job-1".to_string()),
                cmd: CommandSpec {
                    argv: vec![
                        "/bin/sh".to_string(),
                        "-c".to_string(),
                        "echo hi".to_string(),
                    ],
                    cwd: None,
                    env: BTreeMap::new(),
                    limits: None,
                },
                env: BTreeMap::new(),
                stdout_path: "/tmp/stdout.log".to_string(),
                stderr_path: "/tmp/stderr.log".to_string(),
            },
        };
        let bytes = serde_cbor::to_vec(&request).expect("encode request");
        let decoded =
            serde_cbor::from_slice::<ExecRequestEnvelope>(&bytes).expect("decode request");
        assert_eq!(decoded, request);
    }

    #[test]
    /// Verifies response envelope CBOR roundtrips correctly.
    fn roundtrip_response() {
        let response = ExecResponseEnvelope {
            req_id: 7,
            body: ExecResponse::Pong {},
        };
        let bytes = serde_cbor::to_vec(&response).expect("encode response");
        let decoded =
            serde_cbor::from_slice::<ExecResponseEnvelope>(&bytes).expect("decode response");
        assert_eq!(decoded, response);
    }
}
